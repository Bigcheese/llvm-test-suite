# -*- Python -*-

# Configuration file for the 'lit' test runner.

import os
import platform
import tempfile
import signal
import subprocess

kIsWindows = platform.system() == 'Windows'
if kIsWindows:
    import ctypes
    from ctypes import *
    from ctypes.wintypes import *

    SIZE_T = ULONG
    FARPROC = WINFUNCTYPE(c_int)
    LPTHREAD_START_ROUTINE = WINFUNCTYPE(DWORD, LPVOID)
    LPDWORD = POINTER(DWORD)
    PHANDLE = POINTER(HANDLE)
    LPCTSTR = LPCSTR
    LPTSTR = LPSTR
    PDWORD = POINTER(DWORD)
    PVOID = LPVOID
    ULONG_PTR = LPVOID

    class LUID(Structure):
      _fields_ = [("LowPart", DWORD),
                  ("HighPart", LONG)]
    PLUID = POINTER(LUID)

    class LUID_AND_ATTRIBUTES(Structure):
      _fields_ = [("Luid", LUID),
                  ("Attributes", DWORD)]
    PLUID_AND_ATTRIBUTES = POINTER(LUID_AND_ATTRIBUTES)

    ANYSIZE_ARRAY = 1

    class TOKEN_PRIVILEGES(Structure):
      _fields_ = [("PrivilegeCount", DWORD),
                  ("Privileges", LUID_AND_ATTRIBUTES * ANYSIZE_ARRAY)]
    PTOKEN_PRIVILEGES = POINTER(TOKEN_PRIVILEGES)

    class SECURITY_ATTRIBUTES(Structure):
      pass
    LPSECURITY_ATTRIBUTES = POINTER(SECURITY_ATTRIBUTES)

    class THREADENTRY32(Structure):
      _fields_ = [("dwSize", DWORD),
                  ("cntUsage", DWORD),
                  ("th32ThreadID", DWORD),
                  ("th32OwnerProcessID", DWORD),
                  ("tpBasePri", c_long),
                  ("tpDeltaPr", c_long),
                  ("dwFlags", DWORD)]
    LPTHREADENTRY32 = POINTER(THREADENTRY32)

    EXCEPTION_MAXIMUM_PARAMETERS = 15

    class EXCEPTION_RECORD(Structure):
      pass
    EXCEPTION_RECORD._fields_ = [("ExceptionCode", DWORD),
          ("ExceptionFlags", DWORD),
          ("ExceptionRecord", POINTER(EXCEPTION_RECORD)),
          ("ExceptionAddress", PVOID),
          ("NumberParameters", DWORD),
          ("ExceptionInformation", ULONG_PTR * EXCEPTION_MAXIMUM_PARAMETERS)]

    class EXCEPTION_DEBUG_INFO(Structure):
      _fields_ = [("ExceptionRecord", EXCEPTION_RECORD),
                  ("dwFirstChance", DWORD)]

    class CREATE_THREAD_DEBUG_INFO(Structure):
      _fields_ = [("hThread", HANDLE),
                  ("lpThreadLocalBase", LPVOID),
                  ("lpStartAddress", LPTHREAD_START_ROUTINE)]

    class CREATE_PROCESS_DEBUG_INFO(Structure):
      _fields_ = [("hFile", HANDLE),
                  ("hProcess", HANDLE),
                  ("hThread", HANDLE),
                  ("lpBaseOfImage", LPVOID),
                  ("dwDebugInfoFileOffset", DWORD),
                  ("nDebugInfoSize", DWORD),
                  ("lpThreadLocalBase", LPVOID),
                  ("lpStartAddress", LPTHREAD_START_ROUTINE),
                  ("lpImageName", LPVOID),
                  ("fUnicode", WORD)]

    class EXIT_THREAD_DEBUG_INFO(Structure):
      _fields_ = [("dwExitCode", DWORD)]

    class EXIT_PROCESS_DEBUG_INFO(Structure):
      _fields_ = [("dwExitCode", DWORD)]

    class LOAD_DLL_DEBUG_INFO(Structure):
      _fields_ = [("hFile", HANDLE),
                  ("lpBaseOfDll", LPVOID),
                  ("dwDebugInfoFileOffset", DWORD),
                  ("nDebugInfoSize", DWORD),
                  ("lpImageName", LPVOID),
                  ("fUnicode", WORD)]

    class UNLOAD_DLL_DEBUG_INFO(Structure):
      _fields_ = [("lpBaseOfDll", LPVOID)]

    class OUTPUT_DEBUG_STRING_INFO(Structure):
      _fields_ = [("lpDebugStringData", LPSTR),
                  ("fUnicode", WORD),
                  ("nDebugStringLength", WORD)]

    class RIP_INFO(Structure):
      _fields_ = [("dwError", DWORD),
                  ("dwType", DWORD)]

    class DEBUG_EVENT_UNION(Union):
      _fields_ = [("Exception", EXCEPTION_DEBUG_INFO),
                  ("CreateThread", CREATE_THREAD_DEBUG_INFO),
                  ("CreateProcessInfo", CREATE_PROCESS_DEBUG_INFO),
                  ("ExitThread", EXIT_THREAD_DEBUG_INFO),
                  ("ExitProcess", EXIT_PROCESS_DEBUG_INFO),
                  ("LoadDll", LOAD_DLL_DEBUG_INFO),
                  ("UnloadDll", UNLOAD_DLL_DEBUG_INFO),
                  ("DebugString", OUTPUT_DEBUG_STRING_INFO),
                  ("RipInfo", RIP_INFO)]

    class DEBUG_EVENT(Structure):
      _fields_ = [("dwDebugEventCode", DWORD),
                  ("dwProcessId", DWORD),
                  ("dwThreadId", DWORD),
                  ("th32OwnerProcessID", DWORD),
                  ("tpBasePri", c_long),
                  ("tpDeltaPr", c_long),
                  ("dwFlags", DWORD),
                  ("u", DEBUG_EVENT_UNION)]
    LPDEBUG_EVENT = POINTER(DEBUG_EVENT)

    InjectUnhandledExceptionFilterDll = "C:\Users\Michael\Projects\llvm\utils\lit\lit\WindowsInjectedUnhandledExceptionFilter\InjectUnhandledExceptionFilter.dll"
    GetModuleHandle = ctypes.windll.kernel32.GetModuleHandleA
    GetModuleHandle.restype = HMODULE
    GetModuleHandle.argtypes = [LPCSTR]

    GetProcAddress = ctypes.windll.kernel32.GetProcAddress
    GetProcAddress.restype = FARPROC
    GetProcAddress.argtypes = [HMODULE, LPCSTR]

    OpenProcess = ctypes.windll.kernel32.OpenProcess
    OpenProcess.restype = HANDLE
    OpenProcess.argtypes = [DWORD, BOOL, DWORD]

    VirtualAllocEx = ctypes.windll.kernel32.VirtualAllocEx
    VirtualAllocEx.restype = LPVOID
    VirtualAllocEx.argtypes = [HANDLE, LPVOID, SIZE_T, DWORD, DWORD]

    WriteProcessMemory = ctypes.windll.kernel32.WriteProcessMemory
    WriteProcessMemory.restype = BOOL
    WriteProcessMemory.argtypes = [HANDLE, LPVOID, LPCVOID, SIZE_T,
                                   POINTER(SIZE_T)]

    CreateRemoteThread = ctypes.windll.kernel32.CreateRemoteThread
    CreateRemoteThread.restype = HANDLE
    CreateRemoteThread.argtypes = [HANDLE, LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD]

    WaitForSingleObject = ctypes.windll.kernel32.WaitForSingleObject
    WaitForSingleObject.restype = DWORD
    WaitForSingleObject.argtypes = [HANDLE, DWORD]

    VirtualFreeEx = ctypes.windll.kernel32.VirtualFreeEx
    VirtualFreeEx.restype = BOOL
    VirtualFreeEx.argtypes = [HANDLE, LPVOID, SIZE_T, DWORD]

    CloseHandle = ctypes.windll.kernel32.CloseHandle
    CloseHandle.restype = BOOL
    CloseHandle.argtypes = [HANDLE]

    CreateToolhelp32Snapshot = ctypes.windll.kernel32.CreateToolhelp32Snapshot
    CreateToolhelp32Snapshot.restype = HANDLE
    CreateToolhelp32Snapshot.argtypes = [DWORD, DWORD]

    Thread32First = ctypes.windll.kernel32.Thread32First
    Thread32First.restype = BOOL
    Thread32First.argtypes = [HANDLE, LPTHREADENTRY32]

    Thread32Next = ctypes.windll.kernel32.Thread32Next
    Thread32Next.restype = BOOL
    Thread32Next.argtypes = [HANDLE, LPTHREADENTRY32]

    ResumeThread = ctypes.windll.kernel32.ResumeThread
    ResumeThread.restype = DWORD
    ResumeThread.argtypes = [HANDLE]

    DebugActiveProcess = ctypes.windll.kernel32.DebugActiveProcess
    DebugActiveProcess.restype = BOOL
    DebugActiveProcess.argtypes = [DWORD]

    OpenProcessToken = ctypes.windll.kernel32.OpenProcessToken
    OpenProcessToken.restype = BOOL
    OpenProcessToken.argtypes = [HANDLE, DWORD, PHANDLE]

    LookupPrivilegeValue = ctypes.windll.advapi32.LookupPrivilegeValueA
    LookupPrivilegeValue.restype = BOOL
    LookupPrivilegeValue.argtypes = [LPCTSTR, LPCTSTR, PLUID]

    AdjustTokenPrivileges = ctypes.windll.advapi32.AdjustTokenPrivileges
    AdjustTokenPrivileges.restype = BOOL
    AdjustTokenPrivileges.argtypes = [HANDLE, BOOL, PTOKEN_PRIVILEGES, DWORD, PTOKEN_PRIVILEGES, PDWORD]

    GetCurrentProcess = ctypes.windll.kernel32.GetCurrentProcess
    GetCurrentProcess.restype = HANDLE
    GetCurrentProcess.argtypes = []

    WaitForDebugEvent = ctypes.windll.kernel32.WaitForDebugEvent
    WaitForDebugEvent.restype = BOOL
    WaitForDebugEvent.argtypes = [LPDEBUG_EVENT, DWORD]

    ContinueDebugEvent = ctypes.windll.kernel32.ContinueDebugEvent
    ContinueDebugEvent.restype = BOOL
    ContinueDebugEvent.argtypes = [DWORD, DWORD, DWORD]

    CreateFileMapping = ctypes.windll.kernel32.CreateFileMappingA
    CreateFileMapping.restype = HANDLE
    CreateFileMapping.argtypes = [HANDLE, LPSECURITY_ATTRIBUTES, DWORD, DWORD, DWORD, LPCTSTR]

    MapViewOfFile = ctypes.windll.kernel32.MapViewOfFile
    MapViewOfFile.restype = LPVOID
    MapViewOfFile.argtypes = [HANDLE, DWORD, DWORD, DWORD, SIZE_T]

    GetMappedFileName = ctypes.windll.psapi.GetMappedFileNameA
    GetMappedFileName.restype = DWORD
    GetMappedFileName.argtypes = [HANDLE, LPVOID, LPTSTR, DWORD]

    ModuleHandle = GetModuleHandle("kernel32.dll")
    LoadLibraryAddress = LPTHREAD_START_ROUTINE(GetProcAddress(ModuleHandle, "LoadLibraryA"))

    CREATE_SUSPENDED = 0x00000004
    MEM_COMMIT = 0x1000
    MEM_RELEASE = 0x8000
    PAGE_READWRITE = 0x04
    INFINITE = 0x0FFFFF
    TH32CS_SNAPTHREAD = 0x00000004
    PROCESS_ALL_ACCESS = 0x1F0FFF
    PROCESS_CREATE_THREAD = 0x0002
    PROCESS_SUSPEND_RESUME = 0x0800
    PROCESS_QUERY_INFORMATION = 0x0400
    PROCESS_TERMINATE = 0x0001
    PROCESS_VM_OPERATION = 0x0008
    PROCESS_VM_READ = 0x0010
    PROCESS_VM_WRITE = 0x0020
    TOKEN_QUERY = 0x0008
    TOKEN_ADJUST_PRIVILEGES = 0x0020
    SE_DEBUG_NAME = "SeDebugPrivilege"
    SE_PRIVILEGE_ENABLED = 0x00000002L
    DEBUG_PROCESS = 0x00000001
    EXCEPTION_DEBUG_EVENT = 1
    CREATE_THREAD_DEBUG_EVENT = 2
    CREATE_PROCESS_DEBUG_EVENT = 3
    EXIT_THREAD_DEBUG_EVENT = 4
    EXIT_PROCESS_DEBUG_EVENT = 5
    LOAD_DLL_DEBUG_EVENT = 6
    UNLOAD_DLL_DEBUG_EVENT = 7
    OUTPUT_DEBUG_STRING_EVENT = 8
    RIP_EVENT = 9
    DBG_CONTINUE = 0x00010002L

def GetFilenameFromHandle(handle):
  hfilemap = CreateFileMapping(handle, None, 2, 0, 1, None)
  if hfilemap == None:
      print('CreateFileMapping: ' + str(WinError()))
      return "<filename-lookup-failure>"
  pmem = MapViewOfFile(hfilemap, 4, 0, 0, 1)
  if pmem == None:
      print('MapViewOfFile: ' + str(WinError()))
      return "<filename-lookup-failure>"
  name = create_string_buffer(1024)
  success = GetMappedFileName(GetCurrentProcess(), pmem, name, 1024)
  if not success:
    print('GetMappedFileName: ' + str(WinError()))
    return "<filename-lookup-failure>"
  return name.value
  # convert device name to drive letter
  #buf = create_string_buffer(512)
  #size = windll.kernel32.GetLogicalDriveStringsA(511, buf)
  #names = buf.raw[0:size-1].split("\0")
  #for drive in names:
  #    windll.kernel32.QueryDosDeviceA(drive[0:2], buf, 512)
  #    if name.value.startswith(buf.value):
  #        print "%s%s" % (drive[0:2], name.value[len(buf.value):])
  #        break

def SetPrivilege(hToken, lpszPrivilege, bEnablePrivilege):
    tp = TOKEN_PRIVILEGES()
    luid = LUID()
    success = LookupPrivilegeValue(None, lpszPrivilege, byref(luid))
    if not success:
      print('LookupPrivilegeValue: ' + str(WinError()))
      return False
    tp.PrivilegeCount = 1
    tp.Privileges[0].Luid = luid
    if bEnablePrivilege:
      tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED
    else:
      tp.Privileges[0].Attributes = 0

    # Enable the privilege or disable all privileges.

    success = AdjustTokenPrivileges(hToken, False, byref(tp), ctypes.sizeof(TOKEN_PRIVILEGES), None, None)
    if not success:
      print('AdjustTokenPrivileges: ' + str(WinError()))
      return False

    return True;

def execute_command(command, inject_exception_handler):
  if kIsWindows and inject_exception_handler:
    hToken = HANDLE()
    success = OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, byref(hToken))
    if not  success:
      print('OpenProcessToken: ' + str(WinError()))
      return '', WinError(), 1
    success = SetPrivilege(hToken, SE_DEBUG_NAME, True)
    if not  success:
      print('SetPrivilege: ' + str(WinError()))
      return '', WinError(), 1

    # Start process suspended.
    p = subprocess.Popen(command, stdin=subprocess.PIPE,
                          stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                          creationflags=DEBUG_PROCESS)

    # Inject dll.
    #size = len(InjectUnhandledExceptionFilterDll) + 1
    print('p.pid = %d' % p.pid)
    # ProcessHandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_TERMINATE | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, False, p.pid)
    ProcessHandle = OpenProcess(PROCESS_ALL_ACCESS, False, p.pid)
    if ProcessHandle == None:
      print('OpenProcess: ' + str(WinError()))
      return '', WinError(), 1
    print('ProcessHandle = %d' % ProcessHandle)

    DebugEv = DEBUG_EVENT()
    while True:
      success = WaitForDebugEvent(byref(DebugEv), INFINITE)
      if not success:
        print('WaitForDebugEvent: ' + str(WinError()))
        return '', WinError(), 1
      if DebugEv.dwDebugEventCode == EXCEPTION_DEBUG_EVENT:
        print('EXCEPTION_DEBUG_EVENT')
      elif DebugEv.dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT:
        print('CREATE_THREAD_DEBUG_EVENT')
      elif DebugEv.dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT:
        print('CREATE_PROCESS_DEBUG_EVENT')
      elif DebugEv.dwDebugEventCode == EXIT_THREAD_DEBUG_EVENT:
        print('EXIT_THREAD_DEBUG_EVENT')
      elif DebugEv.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT:
        print('EXIT_PROCESS_DEBUG_EVENT')
        break
      elif DebugEv.dwDebugEventCode == LOAD_DLL_DEBUG_EVENT:
        print('LOAD_DLL_DEBUG_EVENT')
        print(GetFilenameFromHandle(DebugEv.u.LoadDll.hFile))
      elif DebugEv.dwDebugEventCode == UNLOAD_DLL_DEBUG_EVENT:
        print('UNLOAD_DLL_DEBUG_EVENT')
      elif DebugEv.dwDebugEventCode == OUTPUT_DEBUG_STRING_EVENT:
        print('OUTPUT_DEBUG_STRING_EVENT')
      elif DebugEv.dwDebugEventCode == RIP_EVENT:
        print('RIP_EVENT')
      success = ContinueDebugEvent(DebugEv.dwProcessId, DebugEv.dwThreadId, DBG_CONTINUE)
      if not success:
        print('ContinueDebugEvent: ' + str(WinError()))
        return '', WinError(), 1

    print('result = %d' % result)
    if result == 0:
      p.kill()
    else:
      out, err = p.communicate()
      exitCode = p.wait()

  else:
    p = subprocess.Popen(command, stdin=subprocess.PIPE,
                          stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out,err = p.communicate()
    exitCode = p.wait()

  # Detect Ctrl-C in subprocess.
  if exitCode == -signal.SIGINT:
    raise KeyboardInterrupt

  return out, err, exitCode

class LLVMTestSuiteTestFormat(lit.formats.FileBasedTest):
  """
  Custom test format handler for use with the test format use by test-suite.

  There are quite a few different types of tests in this test suite, but they
  can be broken down into two main types:

  # The first type of tests are under SingleSource and contain single files.
    Each file is compiled, run, and the output is compared to
    file.reference_output. The format is simple. It contains lines of output
    with the exit code as the last line as "exit <code>".

  # The second type of tests are under MultiSource and External. These are
    more complicated tests that compile and test applications composed of
    multiple source files. Each application also has a different way of
    dealing with the actual test. These are currently ignored.
  """

  def __init__(self, compilers):
    self.compilers = compilers

  def execute(self, test, lit_config):
    name = test.path_in_suite[-1]
    source_path = test.getSourcePath()

    # Check for reference output.
    root, ext = os.path.splitext(source_path)
    reference_output = root + '.reference_output'
    if not os.path.isfile(reference_output):
      lit.warning('Could not find reference output, skipping test.')
      return lit.Test.UNSUPPORTED, "no reference file!"

    ReferenceOutput = open(reference_output, 'r')
    ReferenceOutputLines = ReferenceOutput.read().splitlines()
    if len(ReferenceOutputLines) == 0:
      lit.warning('Invalid reference output, skipping test.')
      return lit.Test.UNSUPPORTED, "Invalid reference output!"
    ref_out = '\n'.join(["'%s'" % a for a in ReferenceOutputLines[:-1]])
    try:
      ref_exit = int(ReferenceOutputLines[-1].split(' ')[1])
    except:
      ref_exit = 0

    failed = False
    report = ''
    compiler_output = None
    for cc in self.compilers:
      try:
        programs_to_run, compiler_output = cc.compile(source_path)

        if compiler_output.exit_code > 0:
          cmd = compiler_output.cmd
          report += """Command: %s\n""" % ' '.join(["'%s'" % a for a in cmd])
          report += """Exit Code: %d\n""" % compiler_output.exit_code
          report += """Standard Output:\n--\n%s\n--\n""" % compiler_output.stdout
          report += """Standard Error:\n--\n%s\n--\n""" % compiler_output.stderr
          report += "\n\nCompilation Failed!\n\n"
          failed = True

        for cmd in programs_to_run:
          out, err, exit = execute_command(cmd, True)

          if out.splitlines() != ReferenceOutputLines[:-1] or exit != ref_exit:
            report += """Command: %s\n""" % ' '.join(["'%s'" % a for a in cmd])
            report += """Exit Code: %d\n""" % exit
            report += """Reference Exit Code: %d\n""" % ref_exit
            report += """Standard Output:\n--\n%s\n--\n""" % out
            report += """Reference Output:\n--\n%s\n--\n""" % ref_out
            report += """Standard Error:\n--\n%s\n--\n""" % err
            report += "\n\nReference Output Differs!\n\n"
            failed = True
      #except Exception as err:
      #  lit.warning(err)
      #  pass
      finally:
        if compiler_output:
          for f in compiler_output.files_to_delete:
            try:
              os.remove(f)
            except:
              pass

    if failed:
      return lit.Test.FAIL, report
    else:
      return lit.Test.PASS, ""

# name: The name of this test suite.
config.name = 'llvm-test-suite'

# suffixes: A list of file extensions to treat as test files.
config.suffixes = ['.c']

# test_source_root: The root path where tests are located.
config.test_source_root = os.path.dirname(__file__)

#cxx_under_test = lit.params.get('cxx_under_test', None)
#if cxx_under_test is None:
#    lit.fatal('must specify user parameter cxx_under_test '
#              '(e.g., --param=cxx_under_test=clang++)')

class CompilerOutput:
  files_to_delete = None
  stdout = None
  stderr = None
  exit_code = None
  cmd = []

class MSVCCompiler:
  def compile(self, source_path):
    output = CompilerOutput()

    try:
      exec_file = tempfile.NamedTemporaryFile(suffix=".exe", delete=False)
      exec_path = exec_file.name
      output.files_to_delete = [exec_path]
      exec_file.close()

      # cl.exe outputs a .obj in the current directory and there's no way to
      # stop it, so make sure it at least gets cleaned up.

      obj_name = os.path.splitext(os.path.basename(source_path))[0] + '.obj'
      obj_path = os.path.join(os.getcwd(), obj_name)
      output.files_to_delete.append(obj_path)

      cmd = ['cl.exe', '-nologo', '-Ox', '-EHa', '-fp:precise',
            '-Fe%s' % exec_path, source_path]
      output.cmd = cmd

      out, err, exit = execute_command(cmd, False)

      output.stdout = out
      output.stderr = err
      output.exit_code = exit

      if exit == 0:
        return [[exec_path]], output
      else:
        return [], output
    except OSError as err:
      output.exit_code = 1
      output.stderr = err.strerror
      return [], output

class ClangCompiler:
  def __init__(self, bitcode):
    self.bitcode = bitcode

  def compile(self, source_path):
    output = CompilerOutput()

    try:
      if self.bitcode:
        exec_file = tempfile.NamedTemporaryFile(suffix=".bc", delete=False)
        exec_path = exec_file.name
        output.files_to_delete = [exec_path]
        exec_file.close()

        cmd = ['clang', '-O3', '-emit-llvm', '-c', '-o', exec_path,
              source_path]

        progs = [#['lli', '-force-interpreter', exec_path],
                 ['lli', exec_path]]
      else:
        exec_file = tempfile.NamedTemporaryFile(suffix="-llc-mc.exe",
                                                delete=False)
        exec_path = exec_file.name
        output.files_to_delete = [exec_path]
        exec_file.close()

        cmd = ['clang', '-O3', '-integrated-as', '-o', exec_path,
              source_path]

        progs = [[exec_path]]

      output.cmd = cmd

      out, err, exit = execute_command(cmd, True)

      output.stdout = out
      output.stderr = err
      output.exit_code = exit

      if exit == 0:
        return progs, output
      else:
        return [], output
    except OSError as err:
      output.exit_code = 1
      output.stderr = err.strerror
      return [], output

config.test_format = LLVMTestSuiteTestFormat([MSVCCompiler(),
                                              ClangCompiler(True),
                                              ClangCompiler(False)])
