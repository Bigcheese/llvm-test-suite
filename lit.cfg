# -*- Python -*-

# Configuration file for the 'lit' test runner.

from __future__ import print_function
import os
import platform
import tempfile
import signal
import subprocess
import time

kIsWindows = platform.system() == 'Windows'

def execute_command(command):
  p = subprocess.Popen(command, stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  out,err = p.communicate()
  exitCode = p.wait()

  # Detect Ctrl-C in subprocess.
  if exitCode == -signal.SIGINT:
    raise KeyboardInterrupt

  # Remove \r from output on windows because python will expand \n to
  # \r\n, thus giving "\r\r\n".
  if kIsWindows:
    out = out.replace('\r', '')
    err = err.replace('\r', '')

  return out, err, exitCode

def execute_stage(name, command):
  start_time = time.time()
  out, err, exit = execute_command(command)
  elapsed = time.time() - start_time

  res = lit.Test.StageResult(name)
  res.elapsed_time    = elapsed
  res.data['command'] = ' '.join(["%s" % a for a in command])
  res.data['exit']    = exit
  res.data['stdout']  = out
  res.data['stderr']  = err

  return res

class LLVMTestSuiteTestFormat(object):
  """
  Custom test format handler for use with the test format use by test-suite.

  There are quite a few different types of tests in this test suite, but they
  can be broken down into two main types:

  # The first type of tests are under SingleSource and contain single files.
    Each file is compiled, run, and the output is compared to
    file.reference_output. The format is simple. It contains lines of output
    with the exit code as the last line as "exit <code>".

  # The second type of tests are under MultiSource and External. These are
    more complicated tests that compile and test applications composed of
    multiple source files. Each application also has a different way of
    dealing with the actual test. These are currently ignored.
  """
  def getTestsInDirectory(self, testSuite, path_in_suite, litConfig,
                                localConfig):
    source_path = testSuite.getSourcePath(path_in_suite)
    for filename in os.listdir(source_path):
      # Ignore dot files and excluded tests.
      if (filename.startswith('.') or
          filename in localConfig.excludes):
        continue

      # Skip sub-directories, as the main lit tester will look at them.
      filepath = os.path.join(source_path, filename)
      if os.path.isdir(filepath):
        continue

      root,file = os.path.split(filename)
      base,ext = os.path.splitext(file)
      # Get tests for each compiler.
      for (name, compiler) in localConfig.compilers.items():
        # Skip files not ending in suffixes.
        if not ext in localConfig.suffixes:
          continue
        # Skip explicitly unsupported tests.
        if localConfig.unsupported[name] == True or \
           base in localConfig.unsupported[name]:
          lit.note('skipping: ' + '/'.join(path_in_suite + (file,)) + ' on '
                                                                    + name)
          continue
        yield lit.Test.Test(testSuite, path_in_suite + (filename, name),
                            localConfig)

  def get_report(self, stage_results):
    report = ''
    for res in stage_results:
      report += ('-' * 20) + (' Stage: %s ' % res.name) + ('-' * 20) + '\n'
      report += 'elapsed time: %f seconds\n' % res.elapsed_time
      report += 'command: %s\n' % res.data['command']
      report += 'exit: %d\n' % res.data['exit']
      if res.data.get('reference_exit', None) != None:
        report += 'reference_exit: %d\n' % res.data['reference_exit']
      if len(res.data['stdout'].strip()) > 0:
        report += 'stdout\n----------\n%s\n----------\n' % res.data['stdout']
      if res.data.get('reference_stdout', None) != None:
        report += 'reference_stdout\n----------\n%s\n----------\n' % res.data['reference_stdout']
      if len(res.data['stderr'].strip()) > 0:
        report += 'stderr\n----------\n%s\n----------\n' % res.data['stderr']

    return report

  def custom_print_results(self, tests):
    import json
    dump = []
    for test in tests:
      t = {}
      t['name'] = '/'.join(test.path_in_suite)
      t['failed'] = test.result.isFailure
      t['stages'] = []
      for stage in getattr(test, 'stage_results', []):
        s = {}
        s.update(stage.data)
        s['name'] = stage.name
        s['elapsed-time'] = stage.elapsed_time
        t['stages'].append(s)
      dump.append(t)
    print("===== JSON Dump Begin =====")
    print(json.dumps(dump, indent=2))
    print("===== JSON Dump End =====")

  def execute(self, test, litConfig):
    source_path,compilerName = os.path.split(test.getSourcePath())
    compiler = test.config.compilers.get(compilerName, None)
    if not compiler:
      # Try command line.
      compilerNames = lit.params.get('compilers', '').split(',')
      if len(compilerNames) != 1:
        lit.error('When directly naming a test, compilers may have only 1' +
                  'compiler listed.')
      compiler = test.config.compilers.get(compilerNames[0], None)
      if not compiler:
        lit.error('We do not currently support directly calling tests! ' +
                  'Call with --param compilers=<compiler>')
        return lit.Test.UNSUPPORTED, ''
      # Update paths.
      source_path = test.getSourcePath()

    if not os.path.splitext(source_path)[1] in compiler.suffixes:
      return lit.Test.UNSUPPORTED, ''

    # Check for reference output.
    reference_output = os.path.splitext(source_path)[0] + '.reference_output'
    if not os.path.isfile(reference_output):
      lit.warning('Could not find reference output, skipping test.')
      return lit.Test.UNSUPPORTED, "no reference file!"

    ReferenceOutput = open(reference_output, 'r')
    ReferenceOutputLines = ReferenceOutput.read().splitlines()
    if len(ReferenceOutputLines) == 0:
      lit.warning('Invalid reference output, skipping test.')
      return lit.Test.UNSUPPORTED, "Invalid reference output!"
    ref_out = '\n'.join(["%s" % a for a in ReferenceOutputLines[:-1]])
    if len(ref_out) > 0:
      ref_out += '\n'
    try:
      ref_exit = int(ReferenceOutputLines[-1].split(' ')[1])
    except:
      ReferenceOutputLines.append('exit 0')
      ref_exit = 0

    failed = False
    reports = []
    files_to_delete = []
    try:
      result, \
      programs_to_run, \
      stage_results, \
      files_to_delete = compiler.compile(source_path, test.config)

      reports += stage_results

      for result in stage_results:
        if result.data['exit'] != 0:
          failed = True
          break

      for cmd in programs_to_run:
        res = execute_stage('run', cmd)
        try:
          res.data['reference_stdout'] = ref_out
          res.data['reference_exit']   = ref_exit

          if res.data['exit'] != ref_exit:
            failed = True

          if test.config.hashed:
            import hashlib
            md5 = hashlib.md5()
            md5.update(res.data['stdout'])
            output_hash = md5.hexdigest()
            if output_hash != ReferenceOutputLines[0]:
              failed = True
              ref_out = ReferenceOutputLines[0]
          else:
            out_lines = res.data['stdout'].splitlines() + \
                        res.data['stderr'].splitlines()
            if out_lines != ReferenceOutputLines[:-1]:
              failed = True
              res.data['stdout'] = ''
              # Try and compress output. Some of the tests can fail with
              # "infinite" loops of output. Directly outputting this can take
              # up a few MiB...
              num_past_matches = 0
              last_line = ''
              for l in out_lines:
                if l == last_line:
                  num_past_matches += 1
                  if num_past_matches < 5:
                    res.data['stdout'] += l + '\n'
                else:
                  if num_past_matches >= 5:
                    res.data['stdout'] += "lit: elided " + str(num_past_matches) + " duplicates...\n"
                  num_past_matches = 0
                  res.data['stdout'] += l + '\n'
                last_line = l
          if failed:
            if len(res.data['stdout']) > 10000:
              res.data['stdout'] = res.data['stdout'][:10000]
              res.data['stdout'] += '\nlit: stdout too long :(\n'
            if len(res.data['stderr']) > 10000:
              res.data['stderr'] = res.data['stderr'][:10000]
              res.data['stderr'] += '\nlit: stderr too long :(\n'
        except Exception as err:
          res.data['stderr'] += """Failed to run command: %s\n""" % ' '.join(["%s" % a for a in cmd])
          import sys, traceback
          exc_type, exc_value, exc_tb = sys.exc_info()
          res.data['stderr'] += '\n'.join(traceback.format_exception(exc_type,
                                                         exc_value,
                                                         exc_tb))
          failed = True
        reports.append(res)
    finally:
      if files_to_delete:
        for f in files_to_delete:
          try:
            os.remove(f)
          except:
            pass

    test.stage_results = reports
    report = self.get_report(reports)

    if failed:
      return lit.Test.FAIL, report
    else:
      return lit.Test.PASS, report

# name: The name of this test suite.
config.name = 'llvm-test-suite'

# suffixes: A list of file extensions to treat as test files.
config.suffixes = ['.c', '.cpp', '.m', '.mm']

# test_source_root: The root path where tests are located.
config.test_source_root = os.path.dirname(__file__)

#cxx_under_test = lit.params.get('cxx_under_test', None)
#if cxx_under_test is None:
#    lit.fatal('must specify user parameter cxx_under_test '
#              '(e.g., --param=cxx_under_test=clang++)')

class CompilerOutput:
  files_to_delete = None
  stdout = None
  stderr = None
  exit_code = None
  cmd = []

class Compiler(object):
  def parseParamFlags(self, base_flags, param_flags_string):
    import copy
    ret_flags = copy.copy(base_flags)
    if len(param_flags_string) > 0:
      # Figure out if we are replacing, removing, or adding.
      if param_flags_string[0] == '=':
        flags = param_flags_string[1:].split(' ')
        ret_flags = flags
      elif param_flags_string[0:2] == '+=':
        flags = param_flags_string[2:].split(' ')
        ret_flags += flags
      elif param_flags_string[0:2] == '-=':
        flags = param_flags_string[2:].split(' ')
        for f in flags:
          # FIXME: Is there a better way to do this?
          for i in xrange(ret_flags.count(f)):
            ret_flags.remove(f)

    # Strip whitespace and remove empty arguments. gcc doesn't like multiple
    # spaces between arguments.
    ret_flags = [f.strip() for f in ret_flags]
    for f in ret_flags[:]: # Make a copy because we are removing.
      if len(f) == 0:
        ret_flags.remove(f)

    return ret_flags

  def getLinkerFlags(self, localConfig):
    return self.parseParamFlags(localConfig.linker_flags,
                                lit.params.get('linker_flags', ''))

class MSVCCompiler(Compiler):
  def __init__(self):
    # MSVC Doesn't do ObjC.
    self.suffixes = ['.c', 'cpp']

  def getCompilerFlags(self, lang, localConfig):
    all_flags = []
    all_flags += self.parseParamFlags(localConfig.msvc_flags,
                          lit.params.get('msvc_flags', ''))
    if lang == 'c':
      all_flags += self.parseParamFlags(localConfig.msvc_c_flags,
                            lit.params.get('msvc_c_flags', ''))
    elif lang == 'cpp':
      all_flags += self.parseParamFlags(localConfig.msvc_cxx_flags,
                            lit.params.get('msvc_cxx_flags', ''))
    return all_flags

  def compile(self, source_path, localConfig):
    files_to_delete = []
    outputs = []
    ext = os.path.splitext(source_path)[1]
    flags = self.getCompilerFlags({'.c'  : 'c',
                                   '.cpp': 'cpp'}[ext],
                                  localConfig)
    linker_flags = self.getLinkerFlags(localConfig)
    try:
      exec_file = tempfile.NamedTemporaryFile(suffix=".exe", delete=False)
      exec_path = exec_file.name
      files_to_delete = [exec_path]
      exec_file.close()

      # cl.exe outputs a .obj in the current directory and there's no way to
      # stop it, so make sure it at least gets cleaned up.
      obj_name = os.path.splitext(os.path.basename(source_path))[0] + '.obj'
      obj_path = os.path.join(os.getcwd(), obj_name)
      files_to_delete.append(obj_path)

      cmd = ['cl'] + flags + linker_flags + ['-Fo%s' % obj_path,
             '-Fe%s' % exec_path, source_path]
      res = execute_stage('compile', cmd)
      outputs.append(res)

      if res.data['exit'] == 0:
        return lit.Test.PASS, [['KillTheDoctor', '-t', '60', exec_path]], outputs, files_to_delete
      else:
        return lit.Test.FAIL, [], outputs, files_to_delete
    except Exception as err:
      import sys, traceback
      exc_type, exc_value, exc_tb = sys.exc_info()
      res = lit.Test.StageResult('EXCEPTION')
      res.elapsed_time = -1
      res.data['command'] = ''
      res.data['exit'] = -1
      res.data['stdout'] = ''
      res.data['stderr'] = '\n'.join(traceback.format_exception(exc_type,
                                                                exc_value,
                                                                exc_tb))
      outputs += [res]
      return lit.Test.UNRESOLVED, [], outputs, files_to_delete

class GCCCompiler(Compiler):
  def __init__(self):
    self.suffixes = ['.c', '.cpp', '.m', '.mm']

  def getCompilerFlags(self, lang, localConfig):
    all_flags = []
    all_flags += self.parseParamFlags(localConfig.gcccompatible_flags,
                          lit.params.get('gcccompatible_flags', ''))
    all_flags += self.parseParamFlags(localConfig.gcc_flags,
                          lit.params.get('gcc_flags', ''))
    if lang == 'c':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_c_flags,
                            lit.params.get('gcccompatible_c_flags', ''))
      all_flags += self.parseParamFlags(localConfig.gcc_c_flags,
                            lit.params.get('gcc_c_flags', ''))
    elif lang == 'cpp':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_cxx_flags,
                            lit.params.get('gcccompatible_cxx_flags', ''))
      all_flags += self.parseParamFlags(localConfig.gcc_cxx_flags,
                            lit.params.get('gcc_cxx_flags', ''))
    elif lang == 'objc':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_objc_flags,
                            lit.params.get('gcccompatible_objc_flags', ''))
      all_flags += self.parseParamFlags(localConfig.gcc_objc_flags,
                            lit.params.get('gcc_objc_flags', ''))
    elif lang == 'objcpp':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_objcxx_flags,
                            lit.params.get('gcccompatible_objcxx_flags', ''))
      all_flags += self.parseParamFlags(localConfig.gcc_objcxx_flags,
                            lit.params.get('gcc_objcxx_flags', ''))
    return all_flags

  def compile(self, source_path, localConfig):
    output = CompilerOutput()
    files_to_delete = []
    ext = os.path.splitext(source_path)[1]
    if ext == ".cpp":
      gcc = "g++"
    else:
      gcc = "gcc"
    flags = self.getCompilerFlags({'.c'  : 'c',
                                   '.cpp': 'cpp',
                                   '.m'  : 'objc',
                                   '.mm' : 'objcpp'}[ext],
                                  localConfig)
    linker_flags = self.getLinkerFlags(localConfig)
    outputs = []
    try:
      exec_file = tempfile.NamedTemporaryFile(suffix="", delete=False)
      exec_path = exec_file.name
      files_to_delete = [exec_path]
      exec_file.close()

      cmd = [gcc] + flags + linker_flags + ['-o', exec_path, source_path]
      res = execute_stage('compile', cmd)
      outputs.append(res)

      if res.data['exit'] == 0:
        return lit.Test.PASS, [[exec_path]], outputs, files_to_delete
      else:
        return lit.Test.FAIL, [], outputs, files_to_delete
    except Exception as err:
      import sys, traceback
      exc_type, exc_value, exc_tb = sys.exc_info()
      res = lit.Test.StageResult('EXCEPTION')
      res.elapsed_time = -1
      res.data['command'] = ''
      res.data['exit'] = -1
      res.data['stdout'] = ''
      res.data['stderr'] = '\n'.join(traceback.format_exception(exc_type,
                                                                exc_value,
                                                                exc_tb))
      outputs += [res]
      return lit.Test.UNRESOLVED, [], outputs, files_to_delete

class ClangCompiler(Compiler):
  def __init__(self, bitcode):
    self.suffixes = ['.c', '.cpp', '.m', '.mm']
    self.bitcode  = bitcode

  def getCompilerFlags(self, lang, localConfig):
    all_flags = []
    all_flags += self.parseParamFlags(localConfig.gcccompatible_flags,
                          lit.params.get('gcccompatible_flags', ''))
    all_flags += self.parseParamFlags(localConfig.clang_flags,
                          lit.params.get('clang_flags', ''))
    if lang == 'c':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_c_flags,
                            lit.params.get('gcccompatible_c_flags', ''))
      all_flags += self.parseParamFlags(localConfig.clang_c_flags,
                            lit.params.get('clang_c_flags', ''))
    elif lang == 'cpp':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_cxx_flags,
                            lit.params.get('gcccompatible_cxx_flags', ''))
      all_flags += self.parseParamFlags(localConfig.clang_cxx_flags,
                            lit.params.get('clang_cxx_flags', ''))
    elif lang == 'objc':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_objc_flags,
                            lit.params.get('gcccompatible_objc_flags', ''))
      all_flags += self.parseParamFlags(localConfig.clang_objc_flags,
                            lit.params.get('clang_objc_flags', ''))
    elif lang == 'objcpp':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_objcxx_flags,
                            lit.params.get('gcccompatible_objcxx_flags', ''))
      all_flags += self.parseParamFlags(localConfig.clang_objcxx_flags,
                            lit.params.get('clang_objcxx_flags', ''))
    return all_flags

  def compile(self, source_path, localConfig):
    files_to_delete = []
    outputs = []
    cmds = []
    progs = []
    ext = os.path.splitext(source_path)[1]
    if ext == ".cpp":
      clang = "clang++"
    else:
      clang = "clang"
    flags = self.getCompilerFlags({'.c'  : 'c',
                                   '.cpp': 'cpp',
                                   '.m'  : 'objc',
                                   '.mm' : 'objcpp'}[ext],
                                  localConfig)
    linker_flags = self.getLinkerFlags(localConfig)
    try:
      failed = False
      if self.bitcode:
        output = CompilerOutput()
        exec_file = tempfile.NamedTemporaryFile(suffix=".bc", delete=False)
        exec_path = exec_file.name
        files_to_delete.append(exec_path)
        exec_file.close()

        cmd = []
        if kIsWindows:
          cmd += ['KillTheDoctor']
        cmd += [clang] + flags + ['-emit-llvm', '-c', '-o', exec_path,
                                  source_path]
        # We ignore linker_flags because there is no link step here :(.
        cmds.append(cmd)

        jit_cmd = []
        if kIsWindows:
          jit_cmd.extend(['KillTheDoctor', '-t', '60'])
        jit_cmd.extend(['lli', exec_path])

        progs.append(jit_cmd)
      else:
        exec_file_mc = tempfile.NamedTemporaryFile(suffix="-llc-mc.exe",
                                                   delete=False)
        exec_path_mc = exec_file_mc.name
        exec_file_mc.close()
        files_to_delete.append(exec_path_mc)
        exec_file = tempfile.NamedTemporaryFile(suffix="-llc.exe",
                                                delete=False)
        exec_path = exec_file.name
        exec_file.close()
        files_to_delete.append(exec_path)

        if kIsWindows:
          obj_file = tempfile.NamedTemporaryFile(suffix="-llc-mc.obj",
                                                 delete=False)
          obj_path = obj_file.name
          obj_file.close()
          files_to_delete.append(obj_path)
          cmds.append(['KillTheDoctor', clang] + flags +
                      ['-integrated-as', '-c', '-o', obj_path, source_path])
        else:
          cmds.append([clang] + flags + linker_flags + ['-integrated-as', '-o',
                      exec_path_mc, source_path])
          cmds.append([clang] + flags + linker_flags  + ['-no-integrated-as',
                      '-o', exec_path, source_path])
          progs.append([exec_path_mc])
          progs.append([exec_path])

      for cmd in cmds:
        res = execute_stage('compile', cmd)
        outputs.append(res)

        if res.data['exit'] != 0:
          failed = True

      if kIsWindows and res.data['exit'] == 0 and not self.bitcode:
        cmd = ['link.exe', '-nologo', '-defaultlib:libcmt'] + linker_flags + [
               '-out:%s' % exec_path, obj_path]
        progs.append(['KillTheDoctor', '-t', '60', exec_path])

        res = execute_stage('compile.link', cmd)
        outputs.append(res)

        if res.data['exit'] != 0:
          failed = True

      if failed:
        return lit.Test.FAIL, [], outputs, files_to_delete
      else:
        return lit.Test.PASS, progs, outputs, files_to_delete
    except Exception as err:
      import sys, traceback
      exc_type, exc_value, exc_tb = sys.exc_info()
      res = lit.Test.StageResult('EXCEPTION')
      res.elapsed_time = -1
      res.data['command'] = ''
      res.data['exit'] = -1
      res.data['stdout'] = ''
      res.data['stderr'] = '\n'.join(traceback.format_exception(exc_type,
                                                                exc_value,
                                                                exc_tb))
      outputs += [res]
      return lit.Test.UNRESOLVED, [], outputs, files_to_delete

import collections

# So here's how flags work. flags are formatted as [<compiler>_][<lang>]_flags.
# They are loaded first from this config, then lit.site.cfg, then the
# lit.local.cfg's, and finally from the command line using --param. Flags
# specified in lit config files follow Python list rules for replacement,
# appending, and removing. Flags specified in --param are replaced if the first
# char is '=', appended if it is '+=', and removed if it is '-='.
#
# The available flags are:
# * <compiler>_flags are used for all languages on <compiler>.
# * <compiler>_<lang>_flags are used for <lang> in {c, cxx, objc, objcxx} on
#   <compiler>.
# * gcccompatible_[<lang>_]flags are used for all gcc compatible compilers. The
#   lang option is the same as above.
#
# flags are added/removed in the following order AFTER each has been loaded and
# merged:
# * gcccompatible_flags - if the compiler supports them
# * <compiler>_flags
# * gcccompatible_<lang>_flags - if the compiler supports them
# * <compiler>_<lang>_flags
#
# Currently supported compilers are:
# * MSVC - Microsoft Visual C/C++. Which ever version is on the PATH is used.
#   This can be changed by running the vcvars.bat script of the on you want to
#   use and then run lit from that environment.
# * clang - The LLVM C Language Family Compiler. Which ever version is on the
#   PATH is used. (FIXME: This needs to be configurable and should be set in
#   lit.site.cfg by the build system).
# * gcc - The GNU Compiler Collection. Which ever version is on the
#   PATH is used. (FIXME: This needs to be configurable and should be set in
#   lit.site.cfg by the build system).

config.gcccompatible_flags = []
if lit.params.get('no-default-flags', 'False') != 'True':
  config.gcccompatible_flags += [
    '-O3', # Enable full optimizations by default.
    '-fomit-frame-pointer',
    '-march=native',
    ]
config.gcccompatible_c_flags = []
config.gcccompatible_cxx_flags = []
config.gcccompatible_objc_flags = []
config.gcccompatible_objcxx_flags = []

config.msvc_flags = ['-nologo'] # Get rid of the banner the compiler prints.
if lit.params.get('no-default-flags', 'False') != 'True':
  config.msvc_flags += [
    '-fp:precise', # "precise" floating-point model.
    '-Ox',         # Enable full optimizations by default.
    '-Oy', # These are separated to allow individually removing them via
    ]      # --param msvc_flags=-=-O<flag>.
config.msvc_c_flags = []
config.msvc_cxx_flags = []
if lit.params.get('no-default-flags', 'False') != 'True':
  config.msvc_cxx_flags += [
    '-EHa', # Enable C++ exception handling via SEH.
    ]

config.clang_flags = []
config.clang_c_flags = []
config.clang_cxx_flags = []
config.clang_objc_flags = []
config.clang_objcxx_flags = []

config.gcc_flags = []
config.gcc_c_flags = []
config.gcc_cxx_flags = []
config.gcc_objc_flags = []
config.gcc_objcxx_flags = []

config.linker_flags = []
# FIXME: This should depend on the runtime, not OS.
if not kIsWindows:
  config.linker_flags += [
    '-lm', # Link to the math library
    ]

config.compilers = dict()
config.unsupported = collections.defaultdict(list)
config.hashed = False

explicit_compilers = lit.params.get('compilers', False)
if explicit_compilers != False:
  compilers = explicit_compilers.split(',')
  if 'MSVC' in compilers:
    config.compilers['MSVC'] = MSVCCompiler()
  if 'gcc' in compilers:
    config.compilers['gcc'] = GCCCompiler()
  if 'clang' in compilers:
    config.compilers['clang-lli'] = ClangCompiler(True)
    config.compilers['clang-native'] = ClangCompiler(False)
  if 'clang-lli' in compilers:
    config.compilers['clang-lli'] = ClangCompiler(True)
  if 'clang-native' in compilers:
    config.compilers['clang-native'] = ClangCompiler(False)
else:
  if 'VS100COMNTOOLS' in os.environ or \
     'VS90COMNTOOLS' in os.environ or \
     'VS80COMNTOOLS' in os.environ or \
     lit.util.which('cl.exe'):
    config.compilers['MSVC'] = MSVCCompiler()
  if lit.util.which('gcc'):
    config.compilers['gcc'] = GCCCompiler()
  if lit.util.which('clang'):
    config.compilers['clang-lli'] = ClangCompiler(True)
    config.compilers['clang-native'] = ClangCompiler(False)

config.test_format = LLVMTestSuiteTestFormat()

def on_clone(parent, cfg, for_path):
  import copy
  cfg.hashed = parent.hashed
  # Don't mess up parent's vars.
  cfg.unsupported = copy.deepcopy(parent.unsupported)
  cfg.compilers = copy.deepcopy(parent.compilers)

  # [:] makes a copy. Otherwise subdirectories can effect other directories.
  cfg.gcccompatible_flags = parent.gcccompatible_flags[:]
  cfg.gcccompatible_c_flags = parent.gcccompatible_c_flags[:]
  cfg.gcccompatible_cxx_flags = parent.gcccompatible_cxx_flags[:]
  cfg.gcccompatible_objc_flags = parent.gcccompatible_objc_flags[:]
  cfg.gcccompatible_objcxx_flags = parent.gcccompatible_objcxx_flags[:]

  cfg.msvc_flags = parent.msvc_flags[:]
  cfg.msvc_c_flags = parent.msvc_c_flags[:]
  cfg.msvc_cxx_flags = parent.msvc_cxx_flags[:]

  cfg.clang_flags = parent.clang_flags[:]
  cfg.clang_c_flags = parent.clang_c_flags[:]
  cfg.clang_cxx_flags = parent.clang_cxx_flags[:]
  cfg.clang_objc_flags = parent.clang_objc_flags[:]
  cfg.clang_objcxx_flags = parent.clang_objcxx_flags[:]

  cfg.gcc_flags = parent.gcc_flags[:]
  cfg.gcc_c_flags = parent.gcc_c_flags[:]
  cfg.gcc_cxx_flags = parent.gcc_cxx_flags[:]
  cfg.gcc_objc_flags = parent.gcc_objc_flags[:]
  cfg.gcc_objcxx_flags = parent.gcc_objcxx_flags[:]

  cfg.linker_flags = parent.linker_flags[:]

config.on_clone = on_clone
