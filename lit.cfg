# -*- Python -*-

# Configuration file for the 'lit' test runner.

import os
import platform
import tempfile
import signal
import subprocess

kIsWindows = platform.system() == 'Windows'
if kIsWindows:
    import ctypes
    from ctypes import *
    from ctypes.wintypes import *

def execute_command(command, inject_exception_handler):
  if kIsWindows and inject_exception_handler:
    SIZE_T = ULONG
    FARPROC = WINFUNCTYPE(c_int)
    LPTHREAD_START_ROUTINE = WINFUNCTYPE(DWORD, LPVOID)
    LPDWORD = POINTER(DWORD)

    class SECURITY_ATTRIBUTES(Structure):
      pass
    LPSECURITY_ATTRIBUTES = POINTER(SECURITY_ATTRIBUTES)

    class THREADENTRY32(Structure):
      _fields_ = [("dwSize", DWORD),
                 ("cntUsage", DWORD),
                 ("th32ThreadID", DWORD),
                 ("th32OwnerProcessID", DWORD),
                 ("tpBasePri", c_long),
                 ("tpDeltaPr", c_long),
                 ("dwFlags", DWORD)]
    LPTHREADENTRY32 = POINTER(THREADENTRY32)

    InjectUnhandledExceptionFilterDll = "C:\Users\Michael\Projects\llvm\utils\lit\lit\WindowsInjectedUnhandledExceptionFilter\InjectUnhandledExceptionFilter.dll"
    GetModuleHandle = ctypes.windll.kernel32.GetModuleHandleA
    GetModuleHandle.restype = HMODULE
    GetModuleHandle.argtypes = [LPCSTR]

    GetProcAddress = ctypes.windll.kernel32.GetProcAddress
    GetProcAddress.restype = FARPROC
    GetProcAddress.argtypes = [HMODULE, LPCSTR]

    OpenProcess = ctypes.windll.kernel32.OpenProcess
    OpenProcess.restype = HANDLE
    OpenProcess.argtypes = [DWORD, BOOL, DWORD]

    VirtualAllocEx = ctypes.windll.kernel32.VirtualAllocEx
    VirtualAllocEx.restype = LPVOID
    VirtualAllocEx.argtypes = [HANDLE, LPVOID, SIZE_T, DWORD, DWORD]

    WriteProcessMemory = ctypes.windll.kernel32.WriteProcessMemory
    WriteProcessMemory.restype = BOOL
    WriteProcessMemory.argtypes = [HANDLE, LPVOID, LPCVOID, SIZE_T,
                                   POINTER(SIZE_T)]

    CreateRemoteThread = ctypes.windll.kernel32.CreateRemoteThread
    CreateRemoteThread.restype = HANDLE
    CreateRemoteThread.argtypes = [HANDLE, LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD]

    WaitForSingleObject = ctypes.windll.kernel32.WaitForSingleObject
    WaitForSingleObject.restype = DWORD
    WaitForSingleObject.argtypes = [HANDLE, DWORD]

    VirtualFreeEx = ctypes.windll.kernel32.VirtualFreeEx
    VirtualFreeEx.restype = BOOL
    VirtualFreeEx.argtypes = [HANDLE, LPVOID, SIZE_T, DWORD]

    CloseHandle = ctypes.windll.kernel32.CloseHandle
    CloseHandle.restype = BOOL
    CloseHandle.argtypes = [HANDLE]

    CreateToolhelp32Snapshot = ctypes.windll.kernel32.CreateToolhelp32Snapshot
    CreateToolhelp32Snapshot.restype = HANDLE
    CreateToolhelp32Snapshot.argtypes = [DWORD, DWORD]

    Thread32First = ctypes.windll.kernel32.Thread32First
    Thread32First.restype = BOOL
    Thread32First.argtypes = [HANDLE, LPTHREADENTRY32]

    Thread32Next = ctypes.windll.kernel32.Thread32Next
    Thread32Next.restype = BOOL
    Thread32Next.argtypes = [HANDLE, LPTHREADENTRY32]

    ResumeThread = ctypes.windll.kernel32.ResumeThread
    ResumeThread.restype = DWORD
    ResumeThread.argtypes = [HANDLE]

    ModuleHandle = GetModuleHandle("kernel32.dll")
    LoadLibraryAddress = LPTHREAD_START_ROUTINE(GetProcAddress(ModuleHandle, "LoadLibraryA"))

    CREATE_SUSPENDED = 0x00000004
    MEM_COMMIT = 0x1000
    MEM_RELEASE = 0x8000
    PAGE_READWRITE = 0x04
    INFINITE = 0x0FFFFF
    TH32CS_SNAPTHREAD = 0x00000004
    PROCESS_ALL_ACCESS = 0x1F0FFF
    PROCESS_CREATE_THREAD = 0x0002
    PROCESS_SUSPEND_RESUME = 0x0800
    PROCESS_QUERY_INFORMATION = 0x0400
    PROCESS_TERMINATE = 0x0001
    PROCESS_VM_OPERATION = 0x0008
    PROCESS_VM_READ = 0x0010
    PROCESS_VM_WRITE = 0x0020

    # Start process suspended.
    p = subprocess.Popen(command, stdin=subprocess.PIPE,
                          stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                          creationflags=CREATE_SUSPENDED)

    # Inject dll.
    size = len(InjectUnhandledExceptionFilterDll) + 1
    print('p.pid = %d' % p.pid)
    ProcessHandle = OpenProcess(PROCESS_CREATE_THREAD | PROCESS_TERMINATE | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE, False, p.pid)
    if ProcessHandle == None:
      print('OpenProcess: ' + str(WinError()))
      return '', WinError(), 1
    print('ProcessHandle = %d' % ProcessHandle)
    mem = VirtualAllocEx(ProcessHandle, None, size, MEM_COMMIT, PAGE_READWRITE)
    if mem == None:
      print('VirtualAllocEx: ' + str(WinError()))
      return '', WinError(), 1
    print('mem = %d' % mem)
    success = WriteProcessMemory(ProcessHandle, mem, InjectUnhandledExceptionFilterDll,
                                 size, None)
    if not success:
      print('WriteProcessMemory: ' + str(WinError()))
      return '', WinError(), 1
    thread = CreateRemoteThread(ProcessHandle, None, 0, LoadLibraryAddress, mem, CREATE_SUSPENDED, None)
    if thread == None:
      print('CreateRemoteThread: ' + str(WinError()))
      return '', WinError(), 1
    print('thread = %d' % thread)

    # Resume process
    threads = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, p.pid)
    print('threads = %d' % threads)
    tEntry = THREADENTRY32()
    tEntry.dwSize = 28
    result = 0
    Thread32First(threads, byref(tEntry))
    while True:
      if tEntry.th32OwnerProcessID == p.pid:
        result = tEntry.th32ThreadID
        break
      if not Thread32Next(threads, byref(tEntry)):
        break

    print('result = %d' % result)
    if result == 0:
      p.kill()
    else:
      ResumeThread(result)
      # Yay for race conditions!
      ResumeThread(thread)
      WaitForSingleObject(thread, INFINITE)
      VirtualFreeEx(ProcessHandle, mem, size, MEM_RELEASE)
      out,err = p.communicate()
      exitCode = p.wait()

  else:
    p = subprocess.Popen(command, stdin=subprocess.PIPE,
                          stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out,err = p.communicate()
    exitCode = p.wait()

  # Detect Ctrl-C in subprocess.
  if exitCode == -signal.SIGINT:
    raise KeyboardInterrupt

  return out, err, exitCode

class LLVMTestSuiteTestFormat(lit.formats.FileBasedTest):
  """
  Custom test format handler for use with the test format use by test-suite.

  There are quite a few different types of tests in this test suite, but they
  can be broken down into two main types:

  # The first type of tests are under SingleSource and contain single files.
    Each file is compiled, run, and the output is compared to
    file.reference_output. The format is simple. It contains lines of output
    with the exit code as the last line as "exit <code>".

  # The second type of tests are under MultiSource and External. These are
    more complicated tests that compile and test applications composed of
    multiple source files. Each application also has a different way of
    dealing with the actual test. These are currently ignored.
  """

  def __init__(self, compilers):
    self.compilers = compilers

  def execute(self, test, lit_config):
    name = test.path_in_suite[-1]
    source_path = test.getSourcePath()

    # Check for reference output.
    root, ext = os.path.splitext(source_path)
    reference_output = root + '.reference_output'
    if not os.path.isfile(reference_output):
      lit.warning('Could not find reference output, skipping test.')
      return lit.Test.UNSUPPORTED, "no reference file!"

    ReferenceOutput = open(reference_output, 'r')
    ReferenceOutputLines = ReferenceOutput.read().splitlines()
    if len(ReferenceOutputLines) == 0:
      lit.warning('Invalid reference output, skipping test.')
      return lit.Test.UNSUPPORTED, "Invalid reference output!"
    ref_out = '\n'.join(["'%s'" % a for a in ReferenceOutputLines[:-1]])
    try:
      ref_exit = int(ReferenceOutputLines[-1].split(' ')[1])
    except:
      ref_exit = 0

    failed = False
    report = ''
    compiler_output = None
    for cc in self.compilers:
      try:
        programs_to_run, compiler_output = cc.compile(source_path)

        if compiler_output.exit_code > 0:
          cmd = compiler_output.cmd
          report += """Command: %s\n""" % ' '.join(["'%s'" % a for a in cmd])
          report += """Exit Code: %d\n""" % compiler_output.exit_code
          report += """Standard Output:\n--\n%s\n--\n""" % compiler_output.stdout
          report += """Standard Error:\n--\n%s\n--\n""" % compiler_output.stderr
          report += "\n\nCompilation Failed!\n\n"
          failed = True

        for cmd in programs_to_run:
          out, err, exit = execute_command(cmd, True)

          if out.splitlines() != ReferenceOutputLines[:-1] or exit != ref_exit:
            report += """Command: %s\n""" % ' '.join(["'%s'" % a for a in cmd])
            report += """Exit Code: %d\n""" % exit
            report += """Reference Exit Code: %d\n""" % ref_exit
            report += """Standard Output:\n--\n%s\n--\n""" % out
            report += """Reference Output:\n--\n%s\n--\n""" % ref_out
            report += """Standard Error:\n--\n%s\n--\n""" % err
            report += "\n\nReference Output Differs!\n\n"
            failed = True
      #except Exception as err:
      #  lit.warning(err)
      #  pass
      finally:
        if compiler_output:
          for f in compiler_output.files_to_delete:
            try:
              os.remove(f)
            except:
              pass

    if failed:
      return lit.Test.FAIL, report
    else:
      return lit.Test.PASS, ""

# name: The name of this test suite.
config.name = 'llvm-test-suite'

# suffixes: A list of file extensions to treat as test files.
config.suffixes = ['.c']

# test_source_root: The root path where tests are located.
config.test_source_root = os.path.dirname(__file__)

#cxx_under_test = lit.params.get('cxx_under_test', None)
#if cxx_under_test is None:
#    lit.fatal('must specify user parameter cxx_under_test '
#              '(e.g., --param=cxx_under_test=clang++)')

class CompilerOutput:
  files_to_delete = None
  stdout = None
  stderr = None
  exit_code = None
  cmd = []

class MSVCCompiler:
  def compile(self, source_path):
    output = CompilerOutput()

    try:
      exec_file = tempfile.NamedTemporaryFile(suffix=".exe", delete=False)
      exec_path = exec_file.name
      output.files_to_delete = [exec_path]
      exec_file.close()

      # cl.exe outputs a .obj in the current directory and there's no way to
      # stop it, so make sure it at least gets cleaned up.

      obj_name = os.path.splitext(os.path.basename(source_path))[0] + '.obj'
      obj_path = os.path.join(os.getcwd(), obj_name)
      output.files_to_delete.append(obj_path)

      cmd = ['cl.exe', '-nologo', '-Ox', '-EHa', '-fp:precise',
            '-Fe%s' % exec_path, source_path]
      output.cmd = cmd

      out, err, exit = execute_command(cmd, False)

      output.stdout = out
      output.stderr = err
      output.exit_code = exit

      if exit == 0:
        return [[exec_path]], output
      else:
        return [], output
    except OSError as err:
      output.exit_code = 1
      output.stderr = err.strerror
      return [], output

class ClangCompiler:
  def __init__(self, bitcode):
    self.bitcode = bitcode

  def compile(self, source_path):
    output = CompilerOutput()

    try:
      if self.bitcode:
        exec_file = tempfile.NamedTemporaryFile(suffix=".bc", delete=False)
        exec_path = exec_file.name
        output.files_to_delete = [exec_path]
        exec_file.close()

        cmd = ['clang', '-O3', '-emit-llvm', '-c', '-o', exec_path,
              source_path]

        progs = [#['lli', '-force-interpreter', exec_path],
                 ['lli', exec_path]]
      else:
        exec_file = tempfile.NamedTemporaryFile(suffix="-llc-mc.exe",
                                                delete=False)
        exec_path = exec_file.name
        output.files_to_delete = [exec_path]
        exec_file.close()

        cmd = ['clang', '-O3', '-integrated-as', '-o', exec_path,
              source_path]

        progs = [[exec_path]]

      output.cmd = cmd

      out, err, exit = execute_command(cmd, True)

      output.stdout = out
      output.stderr = err
      output.exit_code = exit

      if exit == 0:
        return progs, output
      else:
        return [], output
    except OSError as err:
      output.exit_code = 1
      output.stderr = err.strerror
      return [], output

config.test_format = LLVMTestSuiteTestFormat([MSVCCompiler(),
                                              ClangCompiler(True),
                                              ClangCompiler(False)])
