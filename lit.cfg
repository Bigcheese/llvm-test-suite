# -*- Python -*-

# Configuration file for the 'lit' test runner.

import os
import platform
import tempfile
import signal
import subprocess

kIsWindows = platform.system() == 'Windows'

def execute_command(command):
  p = subprocess.Popen(command, stdin=subprocess.PIPE,
                        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  out,err = p.communicate()
  exitCode = p.wait()

  # Detect Ctrl-C in subprocess.
  if exitCode == -signal.SIGINT:
    raise KeyboardInterrupt

  return out, err, exitCode

class LLVMTestSuiteTestFormat(object):
  """
  Custom test format handler for use with the test format use by test-suite.

  There are quite a few different types of tests in this test suite, but they
  can be broken down into two main types:

  # The first type of tests are under SingleSource and contain single files.
    Each file is compiled, run, and the output is compared to
    file.reference_output. The format is simple. It contains lines of output
    with the exit code as the last line as "exit <code>".

  # The second type of tests are under MultiSource and External. These are
    more complicated tests that compile and test applications composed of
    multiple source files. Each application also has a different way of
    dealing with the actual test. These are currently ignored.
  """
  def getTestsInDirectory(self, testSuite, path_in_suite, litConfig,
                                localConfig):
    source_path = testSuite.getSourcePath(path_in_suite)
    for filename in os.listdir(source_path):
      # Ignore dot files and excluded tests.
      if (filename.startswith('.') or
          filename in localConfig.excludes):
        continue

      # Skip sub-directories, as the main lit tester will look at them.
      filepath = os.path.join(source_path, filename)
      if os.path.isdir(filepath):
        continue

      root,file = os.path.split(filename)
      base,ext = os.path.splitext(file)
      # Get tests for each compiler.
      for (name, compiler) in localConfig.compilers.items():
        # Skip files not ending in suffixes.
        if not ext in localConfig.suffixes:
          continue
        # Skip explicitly unsupported tests.
        if localConfig.unsupported[name] == True or \
           base in localConfig.unsupported[name]:
          lit.note('skipping: ' + '/'.join(path_in_suite + (file,)) + ' on '
                                                                    + name)
          continue
        yield lit.Test.Test(testSuite, path_in_suite + (filename, name),
                            localConfig)

  def execute(self, test, litConfig):
    source_path,compilerName = os.path.split(test.getSourcePath())
    compiler = test.config.compilers.get(compilerName, None)
    if not compiler:
      # Try command line.
      compilerName = lit.params.get('single-test-compiler', None)
      compiler = test.config.compilers.get(compilerName, None)
      if not compiler:
        lit.error('We do not currently support directly calling tests! ' +
                  'Call with --param single-test-compiler=<compiler>')
        return lit.Test.UNSUPPORTED, ''
      # Update paths.
      source_path = test.getSourcePath()

    if not os.path.splitext(source_path)[1] in compiler.suffixes:
      return lit.Test.UNSUPPORTED, ''

    # Check for reference output.
    reference_output = os.path.splitext(source_path)[0] + '.reference_output'
    if not os.path.isfile(reference_output):
      lit.warning('Could not find reference output, skipping test.')
      return lit.Test.UNSUPPORTED, "no reference file!"

    ReferenceOutput = open(reference_output, 'r')
    ReferenceOutputLines = ReferenceOutput.read().splitlines()
    if len(ReferenceOutputLines) == 0:
      lit.warning('Invalid reference output, skipping test.')
      return lit.Test.UNSUPPORTED, "Invalid reference output!"
    ref_out = '\n'.join(["%s" % a for a in ReferenceOutputLines[:-1]])
    try:
      ref_exit = int(ReferenceOutputLines[-1].split(' ')[1])
    except:
      ReferenceOutputLines.append('exit 0')
      ref_exit = 0

    failed = False
    report = ''
    files_to_delete = []
    try:
      programs_to_run, \
      compiler_outputs, \
      files_to_delete = compiler.compile(source_path, test.config)

      for output in compiler_outputs:
        # Remove \r from output on windows because python will expand \n to
        # \r\n, thus giving "\r\r\n".
        if kIsWindows:
          output.stdout = output.stdout.replace("\r", "")
          output.stderr = output.stderr.replace("\r", "")

        if output.exit_code != 0:
          cmd = output.cmd
          report += """Command: %s\n""" % ' '.join(["%s" % a for a in cmd])
          report += """Exit Code: %d\n""" % output.exit_code
          report += """Standard Output:\n--\n%s\n--\n""" % output.stdout
          report += """Standard Error:\n--\n%s\n--\n""" % output.stderr
          report += "\n\nCompilation Failed!\n\n"
          failed = True

      for cmd in programs_to_run:
        try:
          out, err, exit = execute_command(cmd)

          # Remove \r from output on windows because python will expand \n to
          # \r\n, thus giving "\r\r\n".
          if kIsWindows:
            out = out.replace("\r", "")
            err = err.replace("\r", "")

          failed = False
          if test.config.hashed:
            import hashlib
            md5 = hashlib.md5()
            md5.update(out)
            output_hash = md5.hexdigest()
            if output_hash != ReferenceOutputLines[0]:
              failed = True
              ref_out = ReferenceOutputLines[0]
          else:
            out_lines = out.splitlines()
            if out_lines != ReferenceOutputLines[:-1] or exit != ref_exit:
              # Try and compress output. Some of the tests can fail with
              # "infinite" loops of output. Directly outputting this can take
              # up a few MiB...
              num_past_matches = 0
              last_line = ''
              for l in out_lines:
                if l == last_line:
                  num_past_matches += 1
                  if num_past_matches < 5:
                    out += l + '\n'
                else:
                  if num_past_matches >= 5:
                    out += "lit: elided " + str(num_past_matches) \
                           + " duplicates...\n"
                  num_past_matches = 0
                  out += l + '\n'
                last_line = l
          if failed:
            if len(out) > 10000:
              out = out[:10000]
              out += '\nlit: stdout too long :( (note: the full output was hashed)\n'
            if len(err) > 10000:
              err = err[:10000]
              err += '\nlit: stderr too long :( (note: the full output was hashed)\n'
            report += """Command: %s\n""" % ' '.join(["%s" % a for a in cmd])
            report += """Exit Code: %d\n""" % exit
            report += """Reference Exit Code: %d\n""" % ref_exit
            report += """Standard Output:\n--\n%s\n--\n""" % out
            if test.config.hashed:
              report += """Standard Output (MD5):\n--\n%s\n--\n""" % output_hash
            if test.config.hashed:
              report += """Reference Output (MD5):\n--\n%s\n--\n""" % ref_out
            else:
              report += """Reference Output:\n--\n%s\n--\n""" % ref_out
            report += """Standard Error:\n--\n%s\n--\n""" % err
            report += "\nReference Output Differs!\n"
          else:
            report += """Passed: """
            report += """Command: %s\n""" % ' '.join(["%s" % a for a in cmd])
        except Exception as err:
          report += """Failed to run command: %s\n""" % ' '.join(["%s" % a for a in cmd])
          import sys, traceback
          exc_type, exc_value, exc_tb = sys.exc_info()
          report += '\n'.join(traceback.format_exception(exc_type,
                                                         exc_value,
                                                         exc_tb))
          failed = True
    finally:
      if files_to_delete:
        for f in files_to_delete:
          try:
            os.remove(f)
          except:
            pass

    if failed:
      return lit.Test.FAIL, report
    else:
      return lit.Test.PASS, report

# name: The name of this test suite.
config.name = 'llvm-test-suite'

# suffixes: A list of file extensions to treat as test files.
config.suffixes = ['.c', '.cpp', '.m', '.mm']

# test_source_root: The root path where tests are located.
config.test_source_root = os.path.dirname(__file__)

#cxx_under_test = lit.params.get('cxx_under_test', None)
#if cxx_under_test is None:
#    lit.fatal('must specify user parameter cxx_under_test '
#              '(e.g., --param=cxx_under_test=clang++)')

class CompilerOutput:
  files_to_delete = None
  stdout = None
  stderr = None
  exit_code = None
  cmd = []

class Compiler(object):
  def parseParamFlags(self, base_flags, param_flags_string):
    import copy
    ret_flags = copy.copy(base_flags)
    if len(param_flags_string) > 0:
      # Figure out if we are replacing, removing, or adding.
      if param_flags_string[0] == '=':
        flags = param_flags_string[1:].split(' ')
        ret_flags = flags
      elif param_flags_string[0:2] == '+=':
        flags = param_flags_string[2:].split(' ')
        ret_flags += flags
      elif param_flags_string[0:2] == '-=':
        flags = param_flags_string[2:].split(' ')
        for f in flags:
          # FIXME: Is there a better way to do this?
          for i in xrange(ret_flags.count(f)):
            ret_flags.remove(f)

    # Strip whitespace and remove empty arguments. gcc doesn't like multiple
    # spaces between arguments.
    ret_flags = [f.strip() for f in ret_flags]
    for f in ret_flags[:]: # Make a copy because we are removing.
      if len(f) == 0:
        ret_flags.remove(f)

    return ret_flags

class MSVCCompiler(Compiler):
  def __init__(self):
    # MSVC Doesn't do ObjC.
    self.suffixes = ['.c', 'cpp']

  def getCompilerFlags(self, lang, localConfig):
    all_flags = []
    all_flags += self.parseParamFlags(localConfig.msvc_flags,
                          lit.params.get('msvc_flags', ''))
    if lang == 'c':
      all_flags += self.parseParamFlags(localConfig.msvc_c_flags,
                            lit.params.get('msvc_c_flags', ''))
    elif lang == 'cpp':
      all_flags += self.parseParamFlags(localConfig.msvc_cxx_flags,
                            lit.params.get('msvc_cxx_flags', ''))
    return all_flags

  def compile(self, source_path, localConfig):
    output = CompilerOutput()
    files_to_delete = []
    ext = os.path.splitext(source_path)[1]
    flags = self.getCompilerFlags({'.c'  : 'c',
                                   '.cpp': 'cpp'}[ext],
                                  localConfig)
    try:
      exec_file = tempfile.NamedTemporaryFile(suffix=".exe", delete=False)
      exec_path = exec_file.name
      files_to_delete = [exec_path]
      exec_file.close()

      # cl.exe outputs a .obj in the current directory and there's no way to
      # stop it, so make sure it at least gets cleaned up.
      obj_name = os.path.splitext(os.path.basename(source_path))[0] + '.obj'
      obj_path = os.path.join(os.getcwd(), obj_name)
      files_to_delete.append(obj_path)

      cmd = ['cl'] + flags + ['-Fo%s' % obj_path, '-Fe%s' % exec_path,
                              source_path]
      output.cmd = cmd

      out, err, exit = execute_command(cmd)

      output.stdout = out
      output.stderr = err
      output.exit_code = exit

      if exit == 0:
        return [['KillTheDoctor', '-t', '60', exec_path]], [output], files_to_delete
      else:
        return [], [output], files_to_delete
    except Exception as err:
      import sys, traceback
      output.exit_code = 1
      exc_type, exc_value, exc_tb = sys.exc_info()
      output.stderr = '\n'.join(traceback.format_exception(exc_type,
                                                           exc_value,
                                                           exc_tb))
      return [], [output], files_to_delete

class GCCCompiler(Compiler):
  def __init__(self):
    self.suffixes = ['.c', '.cpp', '.m', '.mm']

  def getCompilerFlags(self, lang, localConfig):
    all_flags = []
    all_flags += self.parseParamFlags(localConfig.gcccompatible_flags,
                          lit.params.get('gcccompatible_flags', ''))
    all_flags += self.parseParamFlags(localConfig.gcc_flags,
                          lit.params.get('gcc_flags', ''))
    if lang == 'c':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_c_flags,
                            lit.params.get('gcccompatible_c_flags', ''))
      all_flags += self.parseParamFlags(localConfig.gcc_c_flags,
                            lit.params.get('gcc_c_flags', ''))
    elif lang == 'cpp':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_cxx_flags,
                            lit.params.get('gcccompatible_cxx_flags', ''))
      all_flags += self.parseParamFlags(localConfig.gcc_cxx_flags,
                            lit.params.get('gcc_cxx_flags', ''))
    elif lang == 'objc':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_objc_flags,
                            lit.params.get('gcccompatible_objc_flags', ''))
      all_flags += self.parseParamFlags(localConfig.gcc_objc_flags,
                            lit.params.get('gcc_objc_flags', ''))
    elif lang == 'objcpp':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_objcxx_flags,
                            lit.params.get('gcccompatible_objcxx_flags', ''))
      all_flags += self.parseParamFlags(localConfig.gcc_objcxx_flags,
                            lit.params.get('gcc_objcxx_flags', ''))
    return all_flags

  def compile(self, source_path, localConfig):
    output = CompilerOutput()
    files_to_delete = []
    ext = os.path.splitext(source_path)[1]
    if ext == ".cpp":
      gcc = "g++"
    else:
      gcc = "gcc"
    flags = self.getCompilerFlags({'.c'  : 'c',
                                   '.cpp': 'cpp',
                                   '.m'  : 'objc',
                                   '.mm' : 'objcpp'}[ext],
                                  localConfig)
    try:
      exec_file = tempfile.NamedTemporaryFile(suffix="", delete=False)
      exec_path = exec_file.name
      files_to_delete = [exec_path]
      exec_file.close()

      cmd = [gcc] + flags + ['-o', exec_path, source_path]
      output.cmd = cmd

      out, err, exit = execute_command(cmd)

      output.stdout = out
      output.stderr = err
      output.exit_code = exit

      if exit == 0:
        return [[exec_path]], [output], files_to_delete
      else:
        return [], [output], files_to_delete
    except Exception as err:
      import sys, traceback
      output.exit_code = 1
      exc_type, exc_value, exc_tb = sys.exc_info()
      output.stderr = '\n'.join(traceback.format_exception(exc_type,
                                                           exc_value,
                                                           exc_tb))
      return [], [output], files_to_delete

class ClangCompiler(Compiler):
  def __init__(self, bitcode):
    self.suffixes = ['.c', '.cpp', '.m', '.mm']
    self.bitcode = bitcode

  def getCompilerFlags(self, lang, localConfig):
    all_flags = []
    all_flags += self.parseParamFlags(localConfig.gcccompatible_flags,
                          lit.params.get('gcccompatible_flags', ''))
    all_flags += self.parseParamFlags(localConfig.clang_flags,
                          lit.params.get('clang_flags', ''))
    if lang == 'c':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_c_flags,
                            lit.params.get('gcccompatible_c_flags', ''))
      all_flags += self.parseParamFlags(localConfig.clang_c_flags,
                            lit.params.get('clang_c_flags', ''))
    elif lang == 'cpp':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_cxx_flags,
                            lit.params.get('gcccompatible_cxx_flags', ''))
      all_flags += self.parseParamFlags(localConfig.clang_cxx_flags,
                            lit.params.get('clang_cxx_flags', ''))
    elif lang == 'objc':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_objc_flags,
                            lit.params.get('gcccompatible_objc_flags', ''))
      all_flags += self.parseParamFlags(localConfig.clang_objc_flags,
                            lit.params.get('clang_objc_flags', ''))
    elif lang == 'objcpp':
      all_flags += self.parseParamFlags(localConfig.gcccompatible_objcxx_flags,
                            lit.params.get('gcccompatible_objcxx_flags', ''))
      all_flags += self.parseParamFlags(localConfig.clang_objcxx_flags,
                            lit.params.get('clang_objcxx_flags', ''))
    return all_flags

  def compile(self, source_path, localConfig):
    files_to_delete = []
    outputs = []
    cmds = []
    progs = []
    ext = os.path.splitext(source_path)[1]
    if ext == ".cpp":
      clang = "clang++"
    else:
      clang = "clang"
    flags = self.getCompilerFlags({'.c'  : 'c',
                                   '.cpp': 'cpp',
                                   '.m'  : 'objc',
                                   '.mm' : 'objcpp'}[ext],
                                  localConfig)
    try:
      failed = False
      if self.bitcode:
        output = CompilerOutput()
        exec_file = tempfile.NamedTemporaryFile(suffix=".bc", delete=False)
        exec_path = exec_file.name
        files_to_delete.append(exec_path)
        exec_file.close()

        cmd = []
        if kIsWindows:
          cmd += ['KillTheDoctor', '--no-user32']
        cmd += [clang] + flags + ['-emit-llvm', '-c', '-o', exec_path,
                                  source_path]
        cmds.append(cmd)

        jit_cmd = []
        if kIsWindows:
          jit_cmd.extend(['KillTheDoctor', '--no-user32', '-t', '60'])
        jit_cmd.extend(['lli', exec_path])

        progs.append(jit_cmd)
      else:
        exec_file_mc = tempfile.NamedTemporaryFile(suffix="-llc-mc.exe",
                                                   delete=False)
        exec_path_mc = exec_file_mc.name
        exec_file_mc.close()
        files_to_delete.append(exec_path_mc)
        exec_file = tempfile.NamedTemporaryFile(suffix="-llc.exe",
                                                delete=False)
        exec_path = exec_file.name
        exec_file.close()
        files_to_delete.append(exec_path)

        if kIsWindows:
          obj_file = tempfile.NamedTemporaryFile(suffix="-llc-mc.obj",
                                                 delete=False)
          obj_path = obj_file.name
          obj_file.close()
          files_to_delete.append(obj_path)
          cmds.append(['KillTheDoctor', '--no-user32', clang] + flags +
                      ['-integrated-as', '-c', '-o', obj_path, source_path])
        else:
          cmds.append([clang] + flags + ['-integrated-as', '-o', exec_path_mc,
                       source_path])
          cmds.append([clang] + flags + ['-no-integrated-as', '-o', exec_path,
                       source_path])
          progs.append([exec_path_mc])
          progs.append([exec_path])

      for cmd in cmds:
        output = CompilerOutput()
        output.cmd = cmd

        out, err, exit = execute_command(cmd)

        output.stdout = out
        output.stderr = err
        output.exit_code = exit
        outputs.append(output)

        if exit != 0:
          failed = True

      if kIsWindows and exit == 0 and not self.bitcode:
        output = CompilerOutput()
        cmd = ['link.exe', '-nologo', '-defaultlib:libcmt',
               '-out:%s' % exec_path, obj_path, '-include:__fltused']
        progs.append(['KillTheDoctor', '-t', '60', exec_path])
        output.cmd = cmd
        out, err, exit = execute_command(cmd)

        output.stdout = out
        output.stderr = err
        output.exit_code = exit
        outputs.append(output)

        if exit != 0:
          failed = True

      if not failed:
        return progs, outputs, files_to_delete
      else:
        return [], outputs, files_to_delete
    except Exception as err:
      import sys, traceback
      output.exit_code = 1
      exc_type, exc_value, exc_tb = sys.exc_info()
      output.stderr = '\n'.join(traceback.format_exception(exc_type,
                                                           exc_value,
                                                           exc_tb))
      return [], outputs, files_to_delete

import collections

# So here's how flags work. flags are formatted as [<compiler>_][<lang>]_flags.
# They are loaded first from this config, then lit.site.cfg, then the
# lit.local.cfg's, and finally from the command line using --param. Flags
# specified in lit config files follow Python list rules for replacement,
# appending, and removing. Flags specified in --param are replaced if the first
# char is '=', appended if it is '+=', and removed if it is '-='.
#
# The available flags are:
# * <compiler>_flags are used for all languages on <compiler>.
# * <compiler>_<lang>_flags are used for <lang> in {c, cxx, objc, objcxx} on
#   <compiler>.
# * gcccompatible_[<lang>_]flags are used for all gcc compatible compilers. The
#   lang option is the same as above.
#
# flags are added/removed in the following order AFTER each has been loaded and
# merged:
# * gcccompatible_flags - if the compiler supports them
# * <compiler>_flags
# * gcccompatible_<lang>_flags - if the compiler supports them
# * <compiler>_<lang>_flags
#
# Currently supported compilers are:
# * MSVC - Microsoft Visual C/C++. Which ever version is on the PATH is used.
#   This can be changed by running the vcvars.bat script of the on you want to
#   use and then run lit from that environment.
# * clang - The LLVM C Language Family Compiler. Which ever version is on the
#   PATH is used. (FIXME: This needs to be configurable and should be set in
#   lit.site.cfg by the build system).
# * gcc - The GNU Compiler Collection. Which ever version is on the
#   PATH is used. (FIXME: This needs to be configurable and should be set in
#   lit.site.cfg by the build system).

config.gcccompatible_flags = []
if lit.params.get('no-default-flags', 'False') != 'True':
  config.gcccompatible_flags += [
    '-O3', # Enable full optimizations by default.
    '-fomit-frame-pointer',
    '-march=native',
    ]
config.gcccompatible_c_flags = []
config.gcccompatible_cxx_flags = []
config.gcccompatible_objc_flags = []
config.gcccompatible_objcxx_flags = []

config.msvc_flags = ['-nologo'] # Get rid of the banner the compiler prints.
if lit.params.get('no-default-flags', 'False') != 'True':
  config.msvc_flags += [
    '-fp:precise', # "precise" floating-point model.
    '-Ox',         # Enable full optimizations by default.
    '-Oy', # These are separated to allow individually removing them via
    ]      # --param msvc_flags=--O<flag>.
config.msvc_c_flags = []
config.msvc_cxx_flags = []
if lit.params.get('no-default-flags', 'False') != 'True':
  config.msvc_cxx_flags += [
    '-EHa', # Enable C++ exception handling via SEH.
    ]

config.clang_flags = []
config.clang_c_flags = []
config.clang_cxx_flags = []
config.clang_objc_flags = []
config.clang_objcxx_flags = []

config.gcc_flags = []
config.gcc_c_flags = []
config.gcc_cxx_flags = []
config.gcc_objc_flags = []
config.gcc_objcxx_flags = []

config.compilers = dict()
config.unsupported = collections.defaultdict(list)
config.hashed = False

if 'VS100COMNTOOLS' in os.environ or \
   'VS90COMNTOOLS' in os.environ or \
   'VS80COMNTOOLS' in os.environ or \
   lit.util.which('cl.exe'):
  config.compilers['MSVC'] = MSVCCompiler()
if lit.util.which('gcc'):
  config.compilers['gcc'] = GCCCompiler()
if lit.util.which('clang'):
  config.compilers['clang-lli'] = ClangCompiler(True)
  config.compilers['clang-native'] = ClangCompiler(False)

config.test_format = LLVMTestSuiteTestFormat()

def on_clone(parent, cfg, for_path):
  import copy
  cfg.hashed = parent.hashed
  # Don't mess up parent's vars.
  cfg.unsupported = copy.deepcopy(parent.unsupported)
  cfg.compilers = copy.deepcopy(parent.compilers)

  # [:] makes a copy. Otherwise subdirectories can effect other directories.
  cfg.gcccompatible_flags = parent.gcccompatible_flags[:]
  cfg.gcccompatible_c_flags = parent.gcccompatible_c_flags[:]
  cfg.gcccompatible_cxx_flags = parent.gcccompatible_cxx_flags[:]
  cfg.gcccompatible_objc_flags = parent.gcccompatible_objc_flags[:]
  cfg.gcccompatible_objcxx_flags = parent.gcccompatible_objcxx_flags[:]

  cfg.msvc_flags = parent.msvc_flags[:]
  cfg.msvc_c_flags = parent.msvc_c_flags[:]
  cfg.msvc_cxx_flags = parent.msvc_cxx_flags[:]

  cfg.clang_flags = parent.clang_flags[:]
  cfg.clang_c_flags = parent.clang_c_flags[:]
  cfg.clang_cxx_flags = parent.clang_cxx_flags[:]
  cfg.clang_objc_flags = parent.clang_objc_flags[:]
  cfg.clang_objcxx_flags = parent.clang_objcxx_flags[:]

  cfg.gcc_flags = parent.gcc_flags[:]
  cfg.gcc_c_flags = parent.gcc_c_flags[:]
  cfg.gcc_cxx_flags = parent.gcc_cxx_flags[:]
  cfg.gcc_objc_flags = parent.gcc_objc_flags[:]
  cfg.gcc_objcxx_flags = parent.gcc_objcxx_flags[:]

config.on_clone = on_clone
